#!/bin/bash

# Copyright (c) 2012
# See LICENSE for details.
#
# Dave Murphy <davem@devkitpro.org>
# Israel Jacquez <mrkotfw@gmail.com>

# Function panic:
#   ${1} => Message
#   ${2} => Exit status code
panic() {
    local _message="${1}"
    local _exit_code=${2}

    printf "${0##*/}: error: %s\n" "${_message}" 1>&2
    exit ${_exit_code}
}

# Look for automated configuration file
if [ -f 'config' ]; then
    source './config'
else
    panic "Configuration file 'config' not found; see config.in" 1
fi

# Function is_set:
#   ${1} => Variable
is_set() {
    if [[ ! "${!1}" && "${!1-_}" ]]; then
        panic "Variable \"${1}\" does not exist in your config file" 1
    fi
}

# Function check_boolean:
#   ${1} => Value
check_boolean() {
    if [[ "${!1}" != "no" && "${!1}" != "yes" ]]; then
        panic "Variable \"${1}\" has an invalid value in your config file" 1
    fi
}

# Function fetch:
#   ${1} => URL
fetch() {
    local _url="${1}"

    "${FETCH}" "${FETCH_FLAGS}" "${_url}"

    local _fetch_exit_code=${?}

    case "${FETCH}" in
        wget)
            # Kludge: It looks like GNU Wget doesn't return the
            # correct exit status code.
            if [ ${_fetch_exit_code} -ge 2 ] && [ ${_fetch_exit_code} -le 8 ]; then
                return 1
            fi
            return 0
            ;;
        *)
            return ${_fetch_exit_code}
    esac
}

for var in "OPTION_DOWNLOAD_TARBALLS" "OPTION_ENABLE_DDD"; do
    is_set "${var}"
    check_boolean "${var}"
done

for var in "BUILD_INSTALL_DIR" "BUILD_SRC_DIR" \
    "BINUTILS_VERSION" "DDD_VERSION" "GCC_VERSION" "GDB_VERSION" "NEWLIB_VERSION" \
    "MAKE" "AWK" "FETCH" "FETCH_FLAGS"; do
    is_set "${var}"
done

message () {
    printf "${0##*/}: notice: %s\n" "${1}"
}

clean_up () {
    ! test -z "${BUILD_SRC_DIR}" || exit 1

    message "Cleaning up '${BUILD_SRC_DIR}'"

    rm -r -f \
        "${BUILD_SRC_DIR}/${SH_TARGET}" \
        "${BUILD_SRC_DIR}/${M68K_TARGET}" \
        "${BUILD_SRC_DIR}/extracted" \

    exit ${1}
}

trap 'clean_up 1' 2 9 15

SH_TARGET='sh-elf'
M68K_TARGET='m68k-elf'

# Sane defaults for building toolchain
CFLAGS="-O2 -pipe"
export "CFLAGS"
CXXFLAGS="${CFLAGS}"
export "CXXFLAGS"
unset "LDFLAGS"

# Add installed devkit to the path, adjusting path on minsys
PATH="${BUILD_INSTALL_DIR}/${SH_TARGET}/bin:${BUILD_INSTALL_DIR}/${M68K_TARGET}/bin:${PATH}"
export "PATH"

# Ask whether to download the source packages or not
GCC="gcc-${GCC_VERSION}.tar.bz2"
GNU_URL="ftp://ftp.gnu.org/gnu"
GCC_URL="${GNU_URL}/gcc/gcc-${GCC_VERSION}/${GCC}"
GCC_SRC_DIR="gcc-${GCC_VERSION}"

BINUTILS="binutils-${BINUTILS_VERSION}.tar.bz2"
BINUTILS_URL="${GNU_URL}/binutils/${BINUTILS}"
BINUTILS_SRC_DIR="binutils-${BINUTILS_VERSION}"

GDB="gdb-${GDB_VERSION}.tar.bz2"
GDB_URL="${GNU_URL}/gdb/${GDB}"
GDB_SRC_DIR="gdb-${GDB_VERSION}"

DDD="ddd-${DDD_VERSION}.tar.gz"
DDD_URL="${GNU_URL}/ddd/${DDD}"
DDD_SRC_DIR="ddd-${DDD_VERSION}"

NEWLIB_URL="ftp://sources.redhat.com/pub/newlib"
NEWLIB="newlib-${NEWLIB_VERSION}.tar.gz"
NEWLIB_URL="${NEWLIB_URL}/${NEWLIB}"
NEWLIB_SRC_DIR="newlib-${NEWLIB_VERSION}"

# Get preferred installation directory and set paths to the sources
# Make sure we have the proper permissions
mkdir -p "${BUILD_INSTALL_DIR}" 1> /dev/null 2>&1 && \
    test -x "${BUILD_INSTALL_DIR}" && \
    test -w "${BUILD_INSTALL_DIR}" && \
    test -r "${BUILD_INSTALL_DIR}" || \
    panic "Couldn't create install directory" 1


cd "${BUILD_SRC_DIR}/"
if [ "${OPTION_DOWNLOAD_TARBALLS}" = "no" ]; then
    [ ! -f "${BINUTILS}" ] && \
        panic "'${BINUTILS}' not found in ${BUILD_SRC_DIR}" 1

    [ ! -f "${GCC}" ] && \
        panic "'${GCC}' not found in ${BUILD_SRC_DIR}" 1

    [ ! -f "${GDB}" ] && \
        panic "'${GDB}' not found in ${BUILD_SRC_DIR}" 1

    if [ "${OPTION_ENABLE_DDD}" = "yes" ]; then
        [ ! -f "${DDD}" ] && \
            panic "'${DDD}' not found in ${BUILD_SRC_DIR}" 1
    fi

    [ ! -f "${NEWLIB}" ] && \
        panic "'${NEWLIB}' not found in ${BUILD_SRC_DIR}" 1
else
    if [ ! -f "${BINUTILS}" ]; then
        message "Downloading \`${BINUTILS}'"
        if ! fetch "${BINUTILS_URL}" 1>> "binutils-${SH_TARGET}.log" 2>&1; then
            panic "Failed to download ${BINUTILS} (see \`${BUILD_SRC_DIR}/binutils-${SH_TARGET}.log')" 1
        fi
    fi

    if [ ! -f "${GCC}" ]; then
        message "Downloading \`${GCC}'"
        if ! fetch "${GCC_URL}"  1>> "gcc-${SH_TARGET}.log" 2>&1; then
            panic "Failed to download ${GCC} (see \`${BUILD_SRC_DIR}/gcc-${SH_TARGET}.log')" 1
        fi
    fi

    if [ ! -f "${GDB}" ]; then
        message "Downloading \`${GDB}'"
        if ! fetch "${GDB_URL}" 1>> "gdb-${SH_TARGET}.log" 2>&1; then
            panic "Failed to download ${GDB} (see \`${BUILD_SRC_DIR}/gdb-${SH_TARGET}.log')" 1
        fi
    fi

    if [ "${OPTION_ENABLE_DDD}" = "yes" ]; then
        if [ ! -f "${DDD}" ]; then
            message "Downloading \`${DDD}'"
            if ! fetch "${DDD_URL}" 1>> "ddd-${SH_TARGET}.log" 2>&1; then
                panic "Failed to download ${DDD} (see \`${BUILD_SRC_DIR}/ddd-${SH_TARGET}.log')" 1
            fi
        fi
    fi

    if [ ! -f "${NEWLIB}" ]; then
        message "Downloading \`${NEWLIB}'"
        if ! fetch "${NEWLIB_URL}" 1>> "newlib-${SH_TARGET}.log" 2>&1; then
            panic "Failed to download ${NEWLIB} (see \`${BUILD_SRC_DIR}/newlib-${SH_TARGET}.log')" 1
        fi
    fi
fi
cd - 1> /dev/null

for target in "${M68K_TARGET}" "${SH_TARGET}"; do
    if [ -f "${BUILD_SRC_DIR}/${target}/build-complete" ]; then
        continue
    fi

    message "Building ${target} target"

    # Begin building
    [ -f "${target}/scripts/extract" ] && . "${target}/scripts/extract"
    [ -f "${target}/scripts/patch" ] && . "${target}/scripts/patch"
    [ -f "${target}/scripts/build" ] && . "${target}/scripts/build"
    [ -f "${target}/scripts/strip" ] && . "${target}/scripts/strip"
    [ -f "${target}/scripts/finish" ] && . "${target}/scripts/finish"
done

# Clean up temporary files and source directories
clean_up 0
